{
  "source": "..\\api\\dataTypes.md",
  "modules": [
    {
      "textRaw": "数据类型 (Data Types)",
      "name": "数据类型_(data_types)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>数据类型是用来约束数据的解释.<br>本章节的数据类型包括 [ number / void / any / object / 泛型 / 交叉类型 ] 等.</p>\n<blockquote>\n<p>注: 此章节的类型概念 与 JavaScript 数据类型 (如 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive/\">基本类型</a>) 以及 TypeScript 数据类型 (如 <a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html\">基础类型</a>) 在概念上可能存在出入, 因此仅适用于对文档内容的辅助理解, 不适用于严格的概念参考.</p>\n</blockquote>\n",
      "modules": [
        {
          "textRaw": "Boolean",
          "name": "boolean",
          "desc": "<p>布尔类型.</p>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#boolean\">boolean</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo(true); /* 符合预期. */\nfoo(false); /* 符合预期. */\nfoo(3); /* 不符合预期. */\n</code></pre>\n<p>需留意 JavaScript 的短路特性:</p>\n<pre><code class=\"lang-js\">/* 符合预期, 相当于 foo(false). */\nfoo(3 &gt; 4);\n\n/* 不符合预期, 相当于 foo(&quot;hello&quot;). */\nfoo(3 &gt; 4 || &quot;hello&quot;);\n\n/* 符合预期, 相当于 foo(false). */\nfoo(3 &gt; 4 &amp;&amp; &quot;hello&quot;);\n\n/* 不符合预期, 相当于 foo(&quot;hello&quot;). */\nfoo(3 &gt; 2 &amp;&amp; &quot;hello&quot;);\n</code></pre>\n",
          "type": "module",
          "displayName": "Boolean"
        },
        {
          "textRaw": "Number",
          "name": "number",
          "desc": "<p>数字类型.</p>\n<p>常用以下表示方法:</p>\n<ul>\n<li><code>3</code> - 整数</li>\n<li><code>+3</code> - 整数<ul>\n<li>结果与 3 相同, 通常仅用于强调正负性</li>\n<li>这里的 &quot;+&quot; 并非符号, 而是一元运算符</li>\n</ul>\n</li>\n<li><code>-3</code> - 负数</li>\n<li><code>3.1</code> - 小数<ul>\n<li>JS 使用 IEEE 754 双精度版本存储数字</li>\n<li>参阅: <a href=\"https://github.com/HXWfromDJTU/blog/issues/20\">0.1 + 0.2 !== 0.3</a></li>\n</ul>\n</li>\n<li><code>3.0</code> - 整数<ul>\n<li>结果与 3 相同, JS 没有 Double 等类型</li>\n</ul>\n</li>\n<li><code>.1</code> - 小数, 省略前导 0, 相当于 0.1</li>\n<li><code>2e3</code> - 科学计数法, 相当于 2 × 10^3, 即 2000<ul>\n<li>符号 e 表示 10 的幂, e 前后的数字分别称为有效数和幂次</li>\n<li>有效数可以为整数或小数字面量:<ul>\n<li><code>1e2</code>, <code>3.1e2</code>, <code>-9e2</code>, <code>0e2</code>, <code>.1e2</code> 均合法</li>\n</ul>\n</li>\n<li>幂次只能为整数字面量:<ul>\n<li><code>1e2</code>, <code>1e-2</code> 均合法</li>\n</ul>\n</li>\n<li>e 的前后不能有变量或括号等符号:<ul>\n<li><code>let num = 3;</code></li>\n<li><code>nume2</code>, <code>(num)e2</code>, <code>(3)e(2)</code>, <code>3e(num)</code> 均不合法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>0x23</code> - 十六进制</li>\n<li><code>0b101</code> - 二进制</li>\n<li><code>0o307</code> - 八进制</li>\n<li><code>NaN</code> - 特殊数值<ul>\n<li>参阅: <a href=\"glossaries#nan\">NaN</a></li>\n</ul>\n</li>\n<li><code>Infinity</code> - 无穷大</li>\n<li><code>-Infinity</code> - 负无穷大</li>\n<li><code>Number.XXX</code> - Number 对象上的常量<ul>\n<li>如 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\">Number.EPSILON</a>, <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE\">Number.MAX_VALUE</a> 等</li>\n</ul>\n</li>\n<li><code>Math.XXX</code> - Math 对象上的常量<ul>\n<li>如 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/PI\">Math.PI</a>, <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/SQRT2\">Math.SQRT2</a>, <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/LN2\">Math.LN2</a> 等</li>\n</ul>\n</li>\n</ul>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#number\">number</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo(3); /* 符合预期. */\nfoo(3.3); /* 符合预期. */\nfoo(3e3); /* 符合预期. */\nfoo(NaN); /* 符合预期. */\n</code></pre>\n<p>JavaScript 的所有数字都是浮点数, 因此 number 类型对 Double, Float, Long, Integer, Short 等均不作区分.</p>\n<pre><code class=\"lang-js\">3.0 === 3; // true\ntypeof new java.lang.Double(5.23).doubleValue(); // &quot;number&quot;\n</code></pre>\n<blockquote>\n<p>注: 如需表示一个很大的数 (超过 <code>2^53 - 1</code>), 需要用 <a href=\"glossaries#bigint\">BigInt</a> 表示.<br>文档中通常不会出现 <code>bigint</code> 类型的数据, 包括 <code>number | bigint</code> 这样的 <a href=\"#联合类型\">联合类型</a> 数据.</p>\n</blockquote>\n",
          "type": "module",
          "displayName": "Number"
        },
        {
          "textRaw": "String",
          "name": "string",
          "desc": "<p>字符串类型.</p>\n<p>常用以下表示方法:</p>\n<ul>\n<li><code>&quot;hello&quot;</code> - 成对双引号 (<code>&quot;</code>)</li>\n<li><code>&#39;hello&#39;</code> - 成对单引号 (<code>&#39;</code>)</li>\n<li><code>&amp;#96;hello&amp;#96;</code> - 成对反引号 (<code>&amp;#96;</code>)<ul>\n<li>参阅: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals\">模板字符串</a></li>\n</ul>\n</li>\n<li><code>转义字符</code><ul>\n<li>如 <code>\\n</code>, <code>\\r</code>, <code>\\uXXXX</code>, <code>\\xXX</code> 等</li>\n<li>参阅: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6\">转义字符</a></li>\n</ul>\n</li>\n</ul>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#string\">string</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo(&quot;3&quot;); /* 符合预期. */\nfoo(&#39;3.3&#39;); /* 符合预期. */\nfoo(`3e3 equals to ${3000}`); /* 符合预期. */\nfoo(NaN.toString()); /* 符合预期. */\n</code></pre>\n",
          "type": "module",
          "displayName": "String"
        },
        {
          "textRaw": "Array",
          "name": "array",
          "desc": "<p>数组类型.</p>\n<p>后缀 &quot;[]&quot; 代表数组类型.<br>如 <code>number[]</code> 代表一个数组, 其中的元素全部为 <a href=\"#number\">number</a> 类型, 且元素数量不限 (包括 0, 即空数组).</p>\n<blockquote>\n<p>注: <code>number[]</code> 与 <code>[number]</code> 不同, 后者表示 <a href=\"#tuple\">元组类型</a>.</p>\n</blockquote>\n<blockquote>\n<p>注: 使用 <code>Array&lt;T&gt;</code> 这样的 <a href=\"#generic\">泛型</a> 表示法也可代表数组类型, 但文档通常只采用后缀表示法.</p>\n</blockquote>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#array\">string[]</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo([ &quot;3&quot; ]); /* 符合预期. */\nfoo([ 3 ]); /* 不符合预期. */\nfoo([ &quot;3&quot;, 3 ]); /* 不符合预期. */\nfoo([]); /* 符合预期. */\n</code></pre>\n",
          "type": "module",
          "displayName": "Array"
        },
        {
          "textRaw": "Tuple",
          "name": "tuple",
          "desc": "<p>元组类型.</p>\n<p>元组类型严格限制数组的对应类型及元素数量.<br>如 <code>[ number, number, string, number ]</code> 有如下限制:<br>&#45; &#45; 数组有且必有 4 个元素;<br>&#45; &#45; 元素类型依次为 number, number, string, number.</p>\n<blockquote>\n<p>注: 需额外注意元组类型与 JSDoc 表示数组方法的异同.<br>另外 JavaScript 中没有元组的概念.</p>\n</blockquote>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#tuple\">&#91;</a> <a href=\"#string\">string</a>, <a href=\"#number\">number</a> <a href=\"#tuple\">&#93;</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo([ &quot;3&quot; ]); /* 不符合预期. */\nfoo([ 3 ]); /* 不符合预期. */\nfoo([ &quot;3&quot;, 3 ]); /* 符合预期. */\nfoo([]); /* 不符合预期. */\n</code></pre>\n",
          "type": "module",
          "displayName": "Tuple"
        },
        {
          "textRaw": "Function",
          "name": "function",
          "desc": "<p>函数类型.</p>\n<p>文档采用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a> 表示一个函数参数.</p>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#function\">() =&gt;</a> <a href=\"#number\">number</a> }</li>\n</ul>\n<p>上述 <a href=\"documentation#方法签名\">方法签名</a> 中, bar 为函数参数, 该函数是一个无参函数且返回值为 number 类型.</p>\n<pre><code class=\"lang-js\">foo(Math.random()); /* 不符合预期. */\n\nfoo(function () {\n    return Math.random();\n}); /* 符合预期. */\n\nfoo(function () {\n    return &#39;hello&#39;;\n}); /* 不符合预期. */\n</code></pre>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#function\">(a: </a><a href=\"#string\">string</a><a href=\"#function\">, b: </a><a href=\"#any\">any</a><a href=\"#function\">) =&gt; </a><a href=\"#string\">string</a> }</li>\n</ul>\n<p>上述 <a href=\"documentation#方法签名\">方法签名</a> 中, bar 为函数参数, 该函数包含两个参函数且返回值为 string 类型.</p>\n<pre><code class=\"lang-js\">/* 参数 a 为 string 类型, b 为 any 类型. */\nfoo(function (a, b) {\n    return a + String(b); /* 字符串拼接. */\n}); /* 符合预期. */\n</code></pre>\n",
          "type": "module",
          "displayName": "Function"
        },
        {
          "textRaw": "RegExp",
          "name": "regexp",
          "desc": "<p>正则表达式类型.</p>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#regexp\">RegExp</a> }</li>\n</ul>\n<p>上述 <a href=\"documentation#方法签名\">方法签名</a> 中, bar 为正则表达式参数, 是 JavaScript 标准 RegExp 类型:</p>\n<ol>\n<li><p>字面量</p>\n<p><code>foo(/hello.+world?/)</code></p>\n</li>\n<li><p>RegExp 构造器</p>\n<p><code>new RegExp(&#39;hello.+world?&#39;)</code></p>\n</li>\n</ol>\n<blockquote>\n<p>参阅: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp\">MDN</a></p>\n</blockquote>\n",
          "type": "module",
          "displayName": "RegExp"
        },
        {
          "textRaw": "Any",
          "name": "any",
          "desc": "<p>任意类型.</p>\n<p>类型 any 能够兼容所有类型.</p>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#any\">any</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo(3); /* 符合预期. */\nfoo([]); /* 符合预期. */\nfoo({}); /* 符合预期. */\nfoo(null); /* 符合预期. */\n</code></pre>\n<p>尽管 any 可以兼容所有类型, 但仍需提供一个具体的类型, 不能省略:</p>\n<pre><code class=\"lang-js\">foo(); /* 不符合预期. */\nfoo(undefined); /* 符合预期. */\n</code></pre>\n",
          "type": "module",
          "displayName": "Any"
        },
        {
          "textRaw": "Void",
          "name": "void",
          "desc": "<p>此类型用于表示一个函数没有返回值.</p>\n",
          "modules": [
            {
              "textRaw": "作为函数体返回值",
              "name": "作为函数体返回值",
              "desc": "<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#any\">any</a> }</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#void\">void</a> }</li>\n</ul>\n<p>Void 作为 foo 函数体的返回值类型, 表示 foo 函数没有返回值:</p>\n<pre><code class=\"lang-js\">function foo() {\n    console.log(&quot;hello&quot;);\n} /* 符合预期. */\n\nfunction foo() {\n    return &quot;hello&quot;;\n} /* 不符合预期. */\n</code></pre>\n",
              "type": "module",
              "displayName": "作为函数体返回值"
            },
            {
              "textRaw": "作为参数返回值",
              "name": "作为参数返回值",
              "desc": "<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#function\">() =&gt;</a> <a href=\"#void\">void</a> }</li>\n</ul>\n<p>上述 <a href=\"documentation#方法签名\">方法签名</a> 中, bar 为函数参数,<br>void 并非表示要求其返回值为 void,<br>它表示 bar 返回的所有值均被忽略 (即不被关心).</p>\n<pre><code class=\"lang-js\">let arr = [];\nfoo(() =&gt; arr.push(Math.random())); /* 符合预期. */\nconsole.log(arr);\n</code></pre>\n",
              "type": "module",
              "displayName": "作为参数返回值"
            },
            {
              "textRaw": "Void 与 Undefined",
              "name": "void_与_undefined",
              "desc": "<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#string\">string</a> }</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#void\">void</a> }</li>\n</ul>\n<p>在 JavaScript 中, 没有 return 语句的函数将默认返回 <a href=\"#undefined\">undefined</a>.<br>因此对于函数体, 返回值为 void 相当于 undefined:</p>\n<pre><code class=\"lang-js\">foo(() =&gt; {\n    return;\n}) /* 符合预期. */;\n\nfoo(() =&gt; {\n    return undefined;\n}) /* 符合预期. */;\n\nfoo(() =&gt; {\n    // Empty body.\n}) /* 符合预期. */;\n\nfoo(() =&gt; {\n    return 3;\n}) /* 不符合预期. */;\n</code></pre>\n<p><strong>foo(bar, baz)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#function\">() =&gt;</a> <a href=\"#void\">void</a> }</li>\n<li><strong>baz</strong> { <a href=\"#function\">() =&gt;</a> <a href=\"#undefined\">undefined</a> }</li>\n</ul>\n<p>对于函数参数, 返回值 void 与 返回值 undefined 意义不同.<br>void 表示返回的所有值均被忽略 (参阅 <a href=\"#作为参数返回值\">作为参数返回值</a>),<br>而 undefined 表示返回值必须为 undefined 类型.</p>\n<pre><code class=\"lang-js\">foo(\n    /* bar = */ () =&gt; {\n        return;\n    }, /* 符合预期. */\n    /* baz = */ () =&gt; {\n        return;\n    }, /* 符合预期. */\n);\n\nfoo(\n    /* bar = */ () =&gt; {\n        return undefined;\n    }, /* 符合预期. */\n    /* baz = */ () =&gt; {\n        return undefined;\n    }, /* 符合预期. */\n);\n\nfoo(\n    /* bar = */ () =&gt; {\n        // Empty body.\n    }, /* 符合预期. */\n    /* baz = */ () =&gt; {\n        // Empty body.\n    }, /* 符合预期. */\n);\n\nfoo(\n    /* bar = */ () =&gt; {\n        return 3;\n    }, /* 符合预期. */\n    /* baz = */ () =&gt; {\n        return 3;\n    }, /* 不符合预期. */\n);\n</code></pre>\n<blockquote>\n<p>注: 上述方法签名如果将 void 替换为 any, 就 bar 参数是否符合预期方面而言, 效果是相同的.<br>然而两者在语义上有明确不同, void 表示不关心 bar 的返回值, 而 any 表示任意返回值类型均可接受.<br>在设计自定义 API 或设计 TS 声明文件时, 上述区分将显得尤为重要.</p>\n</blockquote>\n",
              "type": "module",
              "displayName": "Void 与 Undefined"
            }
          ],
          "type": "module",
          "displayName": "Void"
        },
        {
          "textRaw": "Never",
          "name": "Never",
          "modules": [
            {
              "textRaw": "字面量对象类型",
              "name": "字面量对象类型",
              "desc": "<p>{{ a: number }}</p>\n",
              "type": "module",
              "displayName": "字面量对象类型"
            }
          ],
          "type": "module",
          "displayName": "Object"
        },
        {
          "textRaw": "Object",
          "name": "object",
          "modules": [
            {
              "textRaw": "字面量对象类型",
              "name": "字面量对象类型",
              "desc": "<p>{{ a: number }}</p>\n",
              "type": "module",
              "displayName": "字面量对象类型"
            }
          ],
          "type": "module",
          "displayName": "Object"
        },
        {
          "textRaw": "Null",
          "name": "Null",
          "desc": "<p>参阅: <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Null/\">MDN #术语</a> / <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null/\">MDN #操作符</a> / <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish/\">MDN #Nullish</a></p>\n",
          "type": "module",
          "displayName": "Undefined"
        },
        {
          "textRaw": "Undefined",
          "name": "undefined",
          "desc": "<pre><code class=\"lang-js\">// device.vibrate(text: string, delay?: number): void\ntypeof device.vibrate(&quot;hello&quot;) === &quot;undefined&quot;; // true\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/undefined/\">MDN #术语</a> / <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined/\">MDN #全局对象</a></p>\n</blockquote>\n",
          "type": "module",
          "displayName": "Undefined"
        },
        {
          "textRaw": "RegExPattern",
          "name": "regexpattern",
          "desc": "<p>正则表达式模式类型.</p>\n<p>通常只在 <a href=\"#pattern\">操纵泛型</a> 中使用.</p>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#pattern\">Pattern</a><a href=\"#generic\">&lt;</a><a href=\"#regexp\">/^\\d+$/</a><a href=\"#generic\">&gt;</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo(&quot;1&quot;); /* 符合预期. */\nfoo(&quot;123&quot;); /* 符合预期. */\nfoo(&quot;hello&quot;); /* 不符合预期. */\nfoo(&quot;1e3&quot;); /* 不符合预期. */\nfoo(&quot;1.3&quot;); /* 不符合预期. */\n</code></pre>\n",
          "type": "module",
          "displayName": "RegExPattern"
        },
        {
          "textRaw": "联合类型",
          "name": "联合类型",
          "type": "module",
          "displayName": "联合类型"
        }
      ],
      "type": "module",
      "displayName": "数据类型 (Data Types)"
    },
    {
      "textRaw": "操作符",
      "name": "操作符",
      "modules": [
        {
          "textRaw": "condition",
          "name": "condition",
          "type": "module",
          "displayName": "readonly"
        },
        {
          "textRaw": "readonly",
          "name": "readonly",
          "type": "module",
          "displayName": "readonly"
        }
      ],
      "type": "module",
      "displayName": "操作符"
    },
    {
      "textRaw": "操纵泛型",
      "name": "操纵泛型",
      "desc": "<p>例如 Array<T></p>\n",
      "modules": [
        {
          "textRaw": "Uppercase",
          "name": "uppercase",
          "desc": "<p><strong>Uppercase&lt;T&gt;: string</strong></p>\n<p>通常用于输出转换.<br>接受 string 类型并生成所有字母大写的同类型数据.</p>\n",
          "type": "module",
          "displayName": "Uppercase"
        },
        {
          "textRaw": "Lowercase",
          "name": "lowercase",
          "desc": "<p><strong>Lowercase&lt;T&gt;: string</strong></p>\n<p>通常用于输出转换.<br>接受 string 类型并生成所有字母小写的同类型数据.</p>\n",
          "type": "module",
          "displayName": "Lowercase"
        },
        {
          "textRaw": "Capitalize",
          "name": "capitalize",
          "desc": "<p><strong>Capitalize&lt;T&gt;: string</strong></p>\n<p>通常用于输出转换.<br>接受 string 类型并生成首字母大写的同类型数据.</p>\n<pre><code class=\"lang-js\">\n</code></pre>\n",
          "type": "module",
          "displayName": "Capitalize"
        },
        {
          "textRaw": "IgnoreCase",
          "name": "ignorecase",
          "desc": "<p><strong>IgnoreCase&lt;T extends string&gt;: T</strong></p>\n<p>通常用于输出转换.<br>接受 string 类型并生成忽略大小写的同类型数据.</p>\n<p>例如, 对于 IgnoreCase&lt;&quot;webUrl&quot;&gt;, 以下数据均符合预期:</p>\n<pre><code class=\"lang-js\">[ &quot;webUrl&quot;, &quot;WEBURL&quot;, &quot;WebUrl&quot;, &quot;WEBurl&quot; ];\n</code></pre>\n<p>但不能在字符串前后或内部插入其他字符,<br>如 [ &quot;WEB_URL&quot; / &quot;web-url&quot; / &quot;#WebUrl&quot; ] 等.</p>\n",
          "type": "module",
          "displayName": "IgnoreCase"
        },
        {
          "textRaw": "Pattern",
          "name": "pattern",
          "desc": "<p><strong>Pattern&lt;<a href=\"#generic\">T</a> <a href=\"#extends\">extends</a> <a href=\"#regexpattern\">RegExPattern</a>&gt;: <a href=\"#string\">string</a></strong></p>\n<p>通常用于输入检查.<br>接受 <a href=\"glossaries#正则表达式\">正则表达式字面量</a> 并生成通过测试的 <a href=\"#string\">string</a> 类型数据.</p>\n<p>Pattern 的泛型通配符 T 在文档中也称作 <a href=\"glossaries#字符串模式\">字符串模式</a>.</p>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#pattern\">Pattern</a><a href=\"#generic\">&lt;</a><a href=\"#regexpattern\">/^https?:/</a><a href=\"#generic\">&gt;</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo(&quot;http is an abbreviation.&quot;); /* 不符合预期. */\nfoo(&quot;https://xxx&quot;); /* 符合预期. */\nfoo(&quot;ftp://xxx&quot;); /* 不符合预期. */\n</code></pre>\n<p>支持 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#%E9%80%9A%E8%BF%87%E6%A0%87%E5%BF%97%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2\">标记参数</a>:</p>\n<p><strong>foo(bar)</strong></p>\n<ul>\n<li><strong>bar</strong> { <a href=\"#pattern\">Pattern</a><a href=\"#generic\">&lt;</a><a href=\"#regexpattern\">/^h...[oy]/i</a><a href=\"#generic\">&gt;</a> }</li>\n</ul>\n<pre><code class=\"lang-js\">foo(&quot;Happy&quot;); /* 符合预期. */\nfoo(&quot;hello&quot;); /* 符合预期. */\nfoo(&quot;Halloween&quot;); /* 符合预期. */\nfoo(&quot;history&quot;); /* 符合预期. */\nfoo(&quot;heroes&quot;); /* 不符合预期. */\n</code></pre>\n<p>为便于理解或重复引用, 有些 Pattern 类型会被重新定义为自定义类型, 如 <a href=\"dataTypes#numberstring\">NumberString</a>.</p>\n<blockquote>\n<p>注: 目前 (2022/08) 在 JSDoc 及 TypeScript 中,<br>均不存在使用正则表达式字面量检查字符串的类型检查 (参阅 <a href=\"https://stackoverflow.com/questions/51445767/how-to-define-a-regex-matched-string-type-in-typescript\">StackOverflow</a>),<br>上述 Pattern 类型仅适用于对文档内容的辅助理解.</p>\n</blockquote>\n",
          "type": "module",
          "displayName": "Pattern"
        },
        {
          "textRaw": "JavaArray",
          "name": "javaarray",
          "desc": "<p>Java Array (Java 数组).</p>\n<pre><code class=\"lang-js\">let javaArr = java.lang.reflect.Array\n    .newInstance(java.lang.Float.TYPE, 3);\n\nconsole.log(util.isJavaArray(javaArr)); // true\nconsole.log(Array.isArray(javaArr)); // false\n</code></pre>\n<p>Java 数组可使用 JavaScript 数组的属性及方法:</p>\n<pre><code class=\"lang-js\">let javaArr = java.lang.reflect.Array\n    .newInstance(java.lang.Float.TYPE, 3);\n\nconsole.log(javaArr.length); // 3\n\nconsole.log(javaArr.slice === Array.prototype.slice); // true\nArray.isArray(javaArr.slice(0)); // true\n</code></pre>\n<p>Java 数组一旦被初始化, 长度将不可改变, [ 改变长度 / 越界赋值 ] 均会失败且抛出异常:</p>\n<pre><code class=\"lang-js\">let javaArr = java.lang.reflect.Array\n    .newInstance(java.lang.Float.TYPE, 3);\n\n/* 静默失败. */\njavaArr.length = 20;\nconsole.log(javaArr.length); // 3\n\n/* push 或 unshift 导致越界抛出异常. */\njavaArr.push(9); /* Error. */\njavaArr.unshift(9); /* Error. */\n\n/* pop 或 shift 不抛出异常但不改变数组长度. */\njavaArr.pop();\nconsole.log(javaArr.length); // 3\njavaArr.shift();\nconsole.log(javaArr.length); // 3\n\n/* 越界访问不抛出异常, 会返回 undefined. */\nconsole.log(javaArr[9]); // undefined\n\n/* 越界赋值将抛出异常. */\njavaArr[9] = 10; /* Error. */\n</code></pre>\n<p>Java 数组中的元素将隐式转换为指定的类型, 同时此类型也会被转换为 JavaScript 类型, 如 Java 的 Integer 等均转换为 Number:</p>\n<pre><code class=\"lang-js\">let javaArr = java.lang.reflect.Array\n    .newInstance(java.lang.Integer.TYPE, 3);\n\nconsole.log(javaArr.join()); // &#39;0,0,0&#39;\n\n/* Number(&#39;1a&#39;) -&gt; NaN */\njavaArr[0] = &#39;1a&#39;;\nconsole.log(javaArr[0]); // NaN\n\n/* Number(&#39;2.2&#39;) -&gt; 2.2 $ JS */\n/* java.lang.Integer(2.2 $ JS) -&gt; 2 $ Java */\n/* Number(2 $ Java) -&gt; 2 $ JS */\njavaArr[2] = &#39;2.2&#39;;\nconsole.log(javaArr[0]); // 2\n\n/* 0xFF $ Hexadecimal == 255 $ Decimal / JS */\n/* java.lang.Integer(255 $ JS) -&gt; 255 $ Java */\n/* Number(255 $ Java) -&gt; 255 $ JS */\njavaArr[0] = 0xFF;\nconsole.log(javaArr[0]); // 255\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html\">Oracle Docs</a></p>\n</blockquote>\n",
          "type": "module",
          "displayName": "JavaArray"
        },
        {
          "textRaw": "JavaArrayList",
          "name": "javaarraylist",
          "desc": "<p>Java ArrayList (Java 数组列表).</p>\n<p>与 <a href=\"#javaarray\">Java Array</a> 不同的是, ArrayList 创建的数组可调整大小:</p>\n<pre><code class=\"lang-js\">let arrList = new java.util.ArrayList();\n\narrList.add(10);\narrList.add(&#39;20&#39;);\narrList.add([ &#39;30&#39; ]);\narrList.add(/40/g);\n\nconsole.log(arrList.length); // 4\n\narrList.forEach((o) =&gt; {\n    // 10 (Number)\n    // 20 (String)\n    // 30 (Array)\n    // /40/g (RegExp)\n    console.log(`${o} (${species(o)})`);\n});\n\narrList.addAll(arrList);\nconsole.log(arrList.length); // 8\n\narrList.clear();\nconsole.log(arrList.length); // 0\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html\">Oracle Docs</a></p>\n</blockquote>\n",
          "type": "module",
          "displayName": "JavaArrayList"
        }
      ],
      "type": "module",
      "displayName": "操纵泛型"
    },
    {
      "textRaw": "自定义类型",
      "name": "自定义类型",
      "modules": [
        {
          "textRaw": "NumberString",
          "name": "numberstring",
          "desc": "<p>数字字符串.</p>\n<p><a href=\"glossaries#字符串模式\">字符串模式</a>: <code>/[+-]?(\\d+(\\.\\d+)?(e\\d+)?)/</code>.</p>\n<pre><code class=\"lang-js\">&quot;12&quot;;\n&quot;-5&quot;;\n&quot;1.5&quot;;\n&quot;1.5e3&quot;;\n</code></pre>\n",
          "type": "module",
          "displayName": "NumberString"
        },
        {
          "textRaw": "ScreenMetricNumberX",
          "name": "screenmetricnumberx",
          "desc": "<p>屏幕横向度量值.</p>\n<p>表示方式:</p>\n<ul>\n<li>数字 { X &gt;= 1 或 X &lt; -1 } - 横向屏幕宽度值</li>\n<li>数字 { X &gt; -1 且 X &lt; 1 } - 横向屏幕宽度值的百分比</li>\n<li>数字 { X == -1 } - 横向屏幕宽度值本身 (代指值)</li>\n</ul>\n<p>例如, 对于下面的参数:</p>\n<p><strong>bottom</strong> { <a href=\"dataTypes#screenmetricnumberx\">ScreenMetricNumberX</a> }</p>\n<p>bottom 赋值为 50, 表示 X 坐标为 50.<br>bottom 赋值为 -80, 表示 X 坐标为 -80.<br>bottom 赋值为 0.5, 表示 X 坐标为 50% 横向屏幕宽度, 即 <code>0.5 * device.width</code>.<br>bottom 赋值为 -0.1, 表示 X 坐标为 -10% 横向屏幕宽度, 即 <code>-0.1 * device.width</code>.<br>bottom 赋值为 -1, 表示 X 坐标为横向屏幕宽度的代指值, 即 <code>device.width</code>.</p>\n",
          "type": "module",
          "displayName": "ScreenMetricNumberX"
        },
        {
          "textRaw": "ScreenMetricNumberY",
          "name": "screenmetricnumbery",
          "desc": "<p>屏幕纵向度量值.</p>\n<p>表示方式:</p>\n<ul>\n<li>数字 { Y &gt;= 1 或 Y &lt; -1 } - 纵向屏幕高度值</li>\n<li>数字 { Y &gt; -1 且 Y &lt; 1 } - 纵向屏幕高度值的百分比</li>\n<li>数字 { Y == -1 } - 纵向屏幕高度值本身 (代指值)</li>\n</ul>\n<p>例如, 对于下面的参数:</p>\n<p><strong>top</strong> { <a href=\"dataTypes#screenmetricnumbery\">ScreenMetricNumberY</a> }</p>\n<p>top 赋值为 50, 表示 Y 坐标为 50.<br>top 赋值为 -80, 表示 Y 坐标为 -80.<br>top 赋值为 0.5, 表示 Y 坐标为 50% 纵向屏幕高度, 即 <code>0.5 * device.height</code>.<br>top 赋值为 -0.1, 表示 Y 坐标为 -10% 纵向屏幕高度, 即 <code>-0.1 * device.height</code>.<br>top 赋值为 -1, 表示 Y 坐标为纵向屏幕高度的代指值, 即 <code>device.height</code>.</p>\n<hr>\n",
          "type": "module",
          "displayName": "ScreenMetricNumberY"
        },
        {
          "textRaw": "OpencvPoint",
          "name": "opencvpoint",
          "desc": "<p>org.opencv.core.Point 别名.\n表示一个点, 作为控件信息时则表示点在屏幕的相对位置.</p>\n<pre><code class=\"lang-js\">let point = pickup(/.+/, &#39;.&#39;);\nconsole.log(`${point.x}, ${point.y}`);\n</code></pre>\n<p>部分属性或方法:</p>\n<ul>\n<li><code>[p#]</code> <a href=\"#p-x\">x</a></li>\n<li><code>[p#]</code> <a href=\"#p-y\">y</a></li>\n</ul>\n<p>常见可以返回此类型的方法:</p>\n<ul>\n<li><a href=\"uiSelectorType#m-pickup\">UiSelector.pickup</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"https://docs.opencv.org/4.x/javadoc/org/opencv/core/Point.html\">OpenCV Docs</a></p>\n</blockquote>\n<hr>\n<p style=\"font: bold 2em sans-serif; color: #FF7043\">org.opencv.core.Point</p>\n\n<hr>\n",
          "modules": [
            {
              "textRaw": "[C] org.opencv.core.Point",
              "name": "[c]_org.opencv.core.point",
              "modules": [
                {
                  "textRaw": "[c] (x, y)",
                  "name": "[c]_(x,_y)",
                  "desc": "<ul>\n<li><strong>x</strong> { <a href=\"dataTypes#number\">number</a> } - 点 X 坐标</li>\n<li><strong>y</strong> { <a href=\"dataTypes#number\">number</a> } - 点 Y 坐标</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-orgopencvcorepoint\">org.opencv.core.Point</a> }</li>\n</ul>\n<p>生成一个点.</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Point(10, 20)); // {10.0, 20.0}\n</code></pre>\n<p>坐标不会被化为整型:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Point(10.8, 20.44)); // {10.8, 20.44}\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] (x, y)"
                },
                {
                  "textRaw": "[c] ()",
                  "name": "[c]_()",
                  "desc": "<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-orgopencvcorepoint\">org.opencv.core.Point</a> }</li>\n</ul>\n<p>生成一个点, 并初始化为 <code>{0, 0}</code> 坐标.</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Point()); // {0.0, 0.0}\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] ()"
                },
                {
                  "textRaw": "[c] (points)",
                  "name": "[c]_(points)",
                  "desc": "<ul>\n<li><strong>points</strong> { <a href=\"dataTypes#number\">number</a><a href=\"dataTypes#array\">[]</a> } - 点坐标数组</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-orgopencvcorepoint\">org.opencv.core.Point</a> }</li>\n</ul>\n<p>生成一个点, 并按指定参数初始化坐标.</p>\n<p>两个坐标:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Point([ 5, 23 ])); // {5.0, 23.0}\n</code></pre>\n<p>一个坐标, 此坐标作为 X 坐标, Y 坐标初始化为 0:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Point([ 5 ])); // {5.0, 0.0}\n</code></pre>\n<p>空数组, X 与 Y 坐标均为 0:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Point([])); // {0.0, 0.0}\n</code></pre>\n<p>超过两个坐标, 多余坐标将被忽略:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Point([ 5, 23, 7, 8, 9 ])); // {5.0, 23.0}\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] (points)"
                }
              ],
              "type": "module",
              "displayName": "[C] org.opencv.core.Point"
            },
            {
              "textRaw": "[p#] x",
              "name": "[p#]_x",
              "desc": "<ul>\n<li>{ <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>点 X 坐标.</p>\n<p>如: Point(<strong>180</strong>, 440) 表示点距屏幕左边缘 180 像素.</p>\n",
              "type": "module",
              "displayName": "[p#] x"
            },
            {
              "textRaw": "[p#] y",
              "name": "[p#]_y",
              "desc": "<ul>\n<li>{ <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>点 Y 坐标.</p>\n<p>如: Point(180, <strong>440</strong>) 表示点距屏幕上边缘 440 像素.</p>\n<hr>\n",
              "type": "module",
              "displayName": "[p#] y"
            }
          ],
          "type": "module",
          "displayName": "OpencvPoint"
        },
        {
          "textRaw": "OpencvSize",
          "name": "opencvsize",
          "desc": "<p>org.opencv.core.Size 别名.\n表示一个长宽尺寸对象, 作为控件信息时则表示控件矩形在屏幕的控件占用尺寸.</p>\n<pre><code class=\"lang-js\">let size = pickup(/.+/, &#39;size&#39;);\nconsole.log(`${size.width}x${size.height}`);\n</code></pre>\n<p>部分属性或方法:</p>\n<ul>\n<li><code>[p#]</code> <a href=\"#p-width\">x</a></li>\n<li><code>[p#]</code> <a href=\"#p-height\">y</a></li>\n</ul>\n<p>常见可以返回此类型的方法:</p>\n<ul>\n<li><a href=\"uiobjectType#m-size\">UiObject.size</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"https://docs.opencv.org/4.x/javadoc/org/opencv/core/Size.html\">OpenCV Docs</a></p>\n</blockquote>\n<hr>\n<p style=\"font: bold 2em sans-serif; color: #FF7043\">org.opencv.core.Size</p>\n\n<hr>\n",
          "modules": [
            {
              "textRaw": "[C] org.opencv.core.Size",
              "name": "[c]_org.opencv.core.size",
              "modules": [
                {
                  "textRaw": "[c] (width, height)",
                  "name": "[c]_(width,_height)",
                  "desc": "<ul>\n<li><strong>width</strong> { <a href=\"dataTypes#number\">number</a> } - 宽度值</li>\n<li><strong>height</strong> { <a href=\"dataTypes#number\">number</a> } - 高度值</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-orgopencvcoresize\">org.opencv.core.Size</a> }</li>\n</ul>\n<p>生成一个尺寸对象.</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Size(100, 200)); // 100x200\n</code></pre>\n<p>坐标不会被化为整型:</p>\n<pre><code class=\"lang-js\">/* 打印时, 数值会转换为整数. */\nconsole.log(new org.opencv.core.Size(1.8, 3.2)); // 1x3\n/* 但获取宽高值时, 依然保留原始值, 不会被化为整型. */\nconsole.log(new org.opencv.core.Size(1.8, 3.2).width); // 1.8\nconsole.log(new org.opencv.core.Size(1.8, 3.2).height); // 3.2\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] (width, height)"
                },
                {
                  "textRaw": "[c] ()",
                  "name": "[c]_()",
                  "desc": "<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-orgopencvcoresize\">org.opencv.core.Size</a> }</li>\n</ul>\n<p>生成一个尺寸对象, 并初始化为 <code>0x0</code> 宽高尺寸.</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Size()); // 0x0\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] ()"
                },
                {
                  "textRaw": "[c] (point)",
                  "name": "[c]_(point)",
                  "desc": "<ul>\n<li><strong>point</strong> { <a href=\"#opencvpoint\">OpencvPoint</a> } - 用于表示尺寸的 &quot;点&quot;</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-orgopencvcoresize\">org.opencv.core.Size</a> }</li>\n</ul>\n<p>生成一个尺寸对象, 并按参数初始化宽高尺寸.</p>\n<pre><code class=\"lang-js\">const { Size, Point } = org.opencv.core;\nconsole.log(new Size(new Point(5, 23))); // 5x23\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] (point)"
                },
                {
                  "textRaw": "[c] (dimensions)",
                  "name": "[c]_(dimensions)",
                  "desc": "<ul>\n<li><strong>dimensions</strong> { <a href=\"dataTypes#number\">number</a><a href=\"dataTypes#array\">[]</a> } - 尺寸值数组</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-orgopencvcoresize\">org.opencv.core.Size</a> }</li>\n</ul>\n<p>生成一个尺寸对象, 并按指定参数初始化宽高尺寸.</p>\n<p>两个尺寸值:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Size([ 5, 23 ])); // 5x23\n</code></pre>\n<p>一个尺寸值, 此尺寸值作为宽度值, 高度值初始化为 0:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Size([ 5 ])); // 5x0\n</code></pre>\n<p>空数组, 宽度尺寸值均为 0:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Size([])); // 0x0\n</code></pre>\n<p>超过两个尺寸值, 多余尺寸值将被忽略:</p>\n<pre><code class=\"lang-js\">console.log(new org.opencv.core.Size([ 5, 23, 7, 8, 9 ])); // 5x23\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] (dimensions)"
                }
              ],
              "type": "module",
              "displayName": "[C] org.opencv.core.Size"
            },
            {
              "textRaw": "[p#] width",
              "name": "[p#]_width",
              "desc": "<ul>\n<li>{ <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>尺寸宽度值.</p>\n",
              "type": "module",
              "displayName": "[p#] width"
            },
            {
              "textRaw": "[p#] height",
              "name": "[p#]_height",
              "desc": "<ul>\n<li>{ <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>尺寸高度值.</p>\n<hr>\n",
              "type": "module",
              "displayName": "[p#] height"
            }
          ],
          "type": "module",
          "displayName": "OpencvSize"
        },
        {
          "textRaw": "AndroidRect",
          "name": "androidrect",
          "desc": "<p>android.graphics.Rect 别名.<br>表示一个矩形, 作为控件信息时则用于表示控件在屏幕的相对位置及空间范围, 又称 <strong>控件矩形</strong>.</p>\n<pre><code class=\"lang-js\">let bounds = pickup(/.+/, &#39;bounds&#39;);\nconsole.log(`${bounds.centerX()}, ${bounds.centerY()}`);\n</code></pre>\n<p>部分属性或方法:</p>\n<ul>\n<li><code>[p#]</code> <a href=\"#p-left\">left</a></li>\n<li><code>[p#]</code> <a href=\"#p-top\">top</a></li>\n<li><code>[p#]</code> <a href=\"#p-right\">right</a></li>\n<li><code>[p#]</code> <a href=\"#p-bottom\">bottom</a></li>\n<li><code>[m#]</code> <a href=\"#m-width\">width()</a></li>\n<li><code>[m#]</code> <a href=\"#m-height\">height()</a></li>\n<li><code>[m#]</code> <a href=\"#m-centerx\">centerX()</a></li>\n<li><code>[m#]</code> <a href=\"#m-centery\">centerY()</a></li>\n<li><code>[m#]</code> <a href=\"#m-exactcenterx\">exactCenterX()</a></li>\n<li><code>[m#]</code> <a href=\"#m-exactcentery\">exactCenterY()</a></li>\n<li><code>[m#]</code> <a href=\"#m-contains\">contains()</a></li>\n<li><code>[m#]</code> <a href=\"#m-intersect\">intersect()</a></li>\n<li><code>[m#]</code> <a href=\"#m-intersects\">intersects()</a></li>\n</ul>\n<p>常见可以返回此类型的方法:</p>\n<ul>\n<li><a href=\"uiObjectType#m-bounds\">UiObject#bounds</a></li>\n<li><a href=\"uiSelectorType#m-pickup\">UiSelector.pickup</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"https://developer.android.com/reference/android/graphics/Rect\">Android Docs</a></p>\n</blockquote>\n<hr>\n<p style=\"font: bold 2em sans-serif; color: #FF7043\">android.graphics.Rect</p>\n\n<hr>\n",
          "modules": [
            {
              "textRaw": "[C] android.graphics.Rect",
              "name": "[c]_android.graphics.rect",
              "modules": [
                {
                  "textRaw": "[c] (left, top, right, bottom)",
                  "name": "[c]_(left,_top,_right,_bottom)",
                  "desc": "<ul>\n<li><strong>left</strong> { <a href=\"dataTypes#number\">number</a> } - 矩形左边界 X 坐标</li>\n<li><strong>top</strong> { <a href=\"dataTypes#number\">number</a> } - 矩形上边界 Y 坐标</li>\n<li><strong>right</strong> { <a href=\"dataTypes#number\">number</a> } - 矩形右边界 X 坐标</li>\n<li><strong>bottom</strong> { <a href=\"dataTypes#number\">number</a> } - 矩形下边界 Y 坐标</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-androidgraphicsrect\">android.graphics.Rect</a> }</li>\n</ul>\n<p>生成一个矩形.</p>\n<pre><code class=\"lang-js\">let rect = new android.graphics.Rect(10, 20, 80, 90);\nconsole.log(rect); // Rect(10, 20 - 80, 90)\n</code></pre>\n<p>如果坐标值为浮点数, 将做向下取整处理:</p>\n<pre><code class=\"lang-js\">let rect = new android.graphics.Rect(10.2, 20.7, 80.1, 90.92);\nconsole.log(rect); // Rect(10, 20 - 80, 90)\n</code></pre>\n<p>坐标值可以为 0 或负数:</p>\n<pre><code class=\"lang-js\">let rect = new android.graphics.Rect(0, 0, -80, -90);\nconsole.log(rect); // Rect(0, 0 - -80, -90)\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] (left, top, right, bottom)"
                },
                {
                  "textRaw": "[c] ()",
                  "name": "[c]_()",
                  "desc": "<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-androidgraphicsrect\">android.graphics.Rect</a> }</li>\n</ul>\n<p>生成一个空矩形.</p>\n<pre><code class=\"lang-js\">let rect = new android.graphics.Rect();\nconsole.log(rect); // Rect(0, 0 - 0, 0)\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] ()"
                },
                {
                  "textRaw": "[c] (rect)",
                  "name": "[c]_(rect)",
                  "desc": "<ul>\n<li><strong>rect</strong> { <a href=\"#c-androidgraphicsrect\">android.graphics.Rect</a> } - 参照矩形</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"#c-androidgraphicsrect\">android.graphics.Rect</a> }</li>\n</ul>\n<p>生成一个新矩形, 并按照参照矩形的参数初始化.</p>\n<pre><code class=\"lang-js\">let rectA = new android.graphics.Rect(10, 20, 80, 90);\nlet rectB = new android.graphics.Rect(rectA);\nconsole.log(rectB); // Rect(10, 20 - 80, 90)\nrectB.top = 1;\nrectB.bottom = 0;\nconsole.log(rectB); // Rect(10, 1 - 80, 0)\nconsole.log(rectA); // Rect(10, 20 - 80, 90)\n</code></pre>\n",
                  "type": "module",
                  "displayName": "[c] (rect)"
                }
              ],
              "type": "module",
              "displayName": "[C] android.graphics.Rect"
            },
            {
              "textRaw": "[p#] left",
              "name": "[p#]_left",
              "desc": "<ul>\n<li>{ <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>矩形左边界 X 坐标.</p>\n<p>如: Rect(<strong>180</strong>, 440, 750, 1200) 表示矩形左边界距屏幕左边缘 180 像素.</p>\n",
              "type": "module",
              "displayName": "[p#] left"
            },
            {
              "textRaw": "[p#] top",
              "name": "[p#]_top",
              "desc": "<ul>\n<li>{ <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>矩形上边界 Y 坐标.</p>\n<p>如: Rect(180, <strong>440</strong>, 750, 1200) 表示矩形上边界距屏幕上边缘 440 像素.</p>\n",
              "type": "module",
              "displayName": "[p#] top"
            },
            {
              "textRaw": "[p#] right",
              "name": "[p#]_right",
              "desc": "<ul>\n<li>{ <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>矩形右边界 X 坐标.</p>\n<p>如: Rect(180, 440, <strong>750</strong>, 1200) 表示矩形右边界距屏幕左边缘 750 像素.</p>\n",
              "type": "module",
              "displayName": "[p#] right"
            },
            {
              "textRaw": "[p#] bottom",
              "name": "[p#]_bottom",
              "desc": "<ul>\n<li>{ <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>矩形下边界 Y 坐标.</p>\n<p>如: Rect(180, 440, 750, <strong>1200</strong>) 表示矩形下边界距屏幕上边缘 1200 像素.</p>\n",
              "type": "module",
              "displayName": "[p#] bottom"
            },
            {
              "textRaw": "[m#] width",
              "name": "[m#]_width",
              "methods": [
                {
                  "textRaw": "width()",
                  "type": "method",
                  "name": "width",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "<ins>**returns**</ins> { [number](dataTypes#number) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [number](dataTypes#number) "
                        }
                      ]
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>矩形宽度.</p>\n<pre><code class=\"lang-js\">let rect = new android.graphics.Rect(180, 440, 750, 1200);\nconsole.log(rect.width()); // 570\n</code></pre>\n<p>宽度可能为 0 或负数:</p>\n<pre><code class=\"lang-js\">let rectA = new android.graphics.Rect(0, 440, 0, 1200);\nconsole.log(rectA.width()); // 0\nlet rectB = new android.graphics.Rect(30, 440, 10, 1200);\nconsole.log(rectB.width()); // -20\n</code></pre>\n"
                }
              ],
              "type": "module",
              "displayName": "[m#] width"
            },
            {
              "textRaw": "[m#] height",
              "name": "[m#]_height",
              "methods": [
                {
                  "textRaw": "height()",
                  "type": "method",
                  "name": "height",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "<ins>**returns**</ins> { [number](dataTypes#number) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [number](dataTypes#number) "
                        }
                      ]
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>矩形高度.</p>\n<pre><code class=\"lang-js\">let rect = new android.graphics.Rect(180, 440, 750, 1200);\nconsole.log(rect.height()); // 760\n</code></pre>\n<p>高度可能为 0 或负数:</p>\n<pre><code class=\"lang-js\">let rectA = new android.graphics.Rect(180, 1200, 750, 1200);\nconsole.log(rectA.height()); // 0\nlet rectB = new android.graphics.Rect(180, 40, 750, 10);\nconsole.log(rectB.height()); // -30\n</code></pre>\n"
                }
              ],
              "type": "module",
              "displayName": "[m#] height"
            },
            {
              "textRaw": "[m#] centerX",
              "name": "[m#]_centerx",
              "methods": [
                {
                  "textRaw": "centerX()",
                  "type": "method",
                  "name": "centerX",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "<ins>**returns**</ins> { [number](dataTypes#number) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [number](dataTypes#number) "
                        }
                      ]
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>矩形中点 X 坐标 (向下取整).</p>\n<pre><code class=\"lang-js\">let rectA = new android.graphics.Rect(180, 440, 750, 1200);\nconsole.log(rectA.centerX()); // 465\n\nlet rectB = new android.graphics.Rect(100, 200, 101, 201);\nconsole.log(rectB.centerX()); // 100\n</code></pre>\n"
                }
              ],
              "type": "module",
              "displayName": "[m#] centerX"
            },
            {
              "textRaw": "[m#] centerY",
              "name": "[m#]_centery",
              "methods": [
                {
                  "textRaw": "centerY()",
                  "type": "method",
                  "name": "centerY",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "<ins>**returns**</ins> { [number](dataTypes#number) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [number](dataTypes#number) "
                        }
                      ]
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>矩形中点 Y 坐标 (向下取整).</p>\n<pre><code class=\"lang-js\">let rectA = new android.graphics.Rect(180, 440, 750, 1200);\nconsole.log(rectA.centerY()); // 820\n\nlet rectB = new android.graphics.Rect(100, 200, 101, 201);\nconsole.log(rectB.centerY()); // 200\n</code></pre>\n"
                }
              ],
              "type": "module",
              "displayName": "[m#] centerY"
            },
            {
              "textRaw": "[m#] exactCenterX",
              "name": "[m#]_exactcenterx",
              "methods": [
                {
                  "textRaw": "exactCenterX()",
                  "type": "method",
                  "name": "exactCenterX",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "<ins>**returns**</ins> { [number](dataTypes#number) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [number](dataTypes#number) "
                        }
                      ]
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>矩形中点 X 坐标 (浮点数).</p>\n<pre><code class=\"lang-js\">let rectA = new android.graphics.Rect(180, 440, 750, 1200);\nconsole.log(rectA.exactCenterX()); // 465\n\nlet rectB = new android.graphics.Rect(100, 200, 101, 201);\nconsole.log(rectB.exactCenterX()); // 100.5\n</code></pre>\n"
                }
              ],
              "type": "module",
              "displayName": "[m#] exactCenterX"
            },
            {
              "textRaw": "[m#] exactCenterY",
              "name": "[m#]_exactcentery",
              "methods": [
                {
                  "textRaw": "exactCenterY()",
                  "type": "method",
                  "name": "exactCenterY",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "<ins>**returns**</ins> { [number](dataTypes#number) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [number](dataTypes#number) "
                        }
                      ]
                    },
                    {
                      "params": []
                    }
                  ],
                  "desc": "<p>矩形中点 Y 坐标 (浮点数).</p>\n<pre><code class=\"lang-js\">let rectA = new android.graphics.Rect(180, 440, 750, 1200);\nconsole.log(rectA.exactCenterY()); // 820\n\nlet rectB = new android.graphics.Rect(100, 200, 101, 201);\nconsole.log(rectB.exactCenterY()); // 200.5\n</code></pre>\n"
                }
              ],
              "type": "module",
              "displayName": "[m#] exactCenterY"
            },
            {
              "textRaw": "[m#] contains",
              "name": "[m#]_contains",
              "methods": [
                {
                  "textRaw": "contains(rect)",
                  "type": "method",
                  "name": "contains",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "**rect** { [android.graphics.Rect](#c-androidgraphicsrect) } - 参照矩形 ",
                          "name": "**rect**",
                          "type": " [android.graphics.Rect](#c-androidgraphicsrect) ",
                          "desc": "参照矩形"
                        },
                        {
                          "textRaw": "<ins>**returns**</ins> { [boolean](dataTypes#boolean) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [boolean](dataTypes#boolean) "
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "rect"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>返回是否包含另一个矩形.<br>参照矩形的所有边均在当前矩形内 (包含边重叠情况) 则满足包含条件.<br>空矩形与任何矩形不存在包含关系.</p>\n<pre><code class=\"lang-js\">let rectThis = new android.graphics.Rect(180, 440, 750, 1200);\n\nlet rectRefA = new android.graphics.Rect(rectThis);\nconsole.log(rectThis.contains(rectRefA)); // true\n\nlet rectRefB = new android.graphics.Rect(200, 440, 750, 1200);\nconsole.log(rectThis.contains(rectRefB)); // true\n\nlet rectRefC = new android.graphics.Rect(); /* 空矩形. */\nconsole.log(rectThis.contains(rectRefC)); // false\n</code></pre>\n"
                }
              ],
              "type": "module",
              "displayName": "[m#] contains"
            },
            {
              "textRaw": "[m#] intersect",
              "name": "[m#]_intersect",
              "methods": [
                {
                  "textRaw": "intersect(rect)",
                  "type": "method",
                  "name": "intersect",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "**rect** { [android.graphics.Rect](#c-androidgraphicsrect) } - 参照矩形 ",
                          "name": "**rect**",
                          "type": " [android.graphics.Rect](#c-androidgraphicsrect) ",
                          "desc": "参照矩形"
                        },
                        {
                          "textRaw": "<ins>**returns**</ins> { [boolean](dataTypes#boolean) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [boolean](dataTypes#boolean) "
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "rect"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>返回是否与参展矩形相交 (不包括边界或点重叠的情况).<br>如果相交, 则返回 true, <strong>且当前矩形被设置为相交部分的矩形</strong>.</p>\n<pre><code class=\"lang-js\">let rectThis = new android.graphics.Rect(0, 0, 600, 600);\nlet rectRef = new android.graphics.Rect(200, 0, 800, 800);\n\nconsole.log(rectThis.intersect(rectRef)); // true\n\n/* rectThis 被修改. */\nconsole.log(rectThis); // Rect(200, 0 - 600, 600) \n</code></pre>\n<p>如果不相交, 则返回 false, 当前矩形不会被修改:</p>\n<pre><code class=\"lang-js\">let rectThis = new android.graphics.Rect(0, 0, 100, 100);\nlet rectRef = new android.graphics.Rect(100, 0, 800, 800);\n\nconsole.log(rectThis.intersect(rectRef)); // false\n\n/* rectThis 保持原来的值. */\nconsole.log(rectThis); // Rect(0, 0 - 100, 100)\n</code></pre>\n<p>空矩形与任意矩形不相交:</p>\n<pre><code class=\"lang-js\">let rectThis = new android.graphics.Rect(0, 0, 100, 100);\nlet rectRef = new android.graphics.Rect();\nconsole.log(rectThis.intersect(rectRef)); // false\n</code></pre>\n"
                }
              ],
              "type": "module",
              "displayName": "[m#] intersect"
            },
            {
              "textRaw": "[m] intersects",
              "name": "[m]_intersects",
              "methods": [
                {
                  "textRaw": "intersects(rectA, rectB)",
                  "type": "method",
                  "name": "intersects",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "**rect** { [android.graphics.Rect](#c-androidgraphicsrect) } - 参照矩形 ",
                          "name": "**rect**",
                          "type": " [android.graphics.Rect](#c-androidgraphicsrect) ",
                          "desc": "参照矩形"
                        },
                        {
                          "textRaw": "<ins>**returns**</ins> { [boolean](dataTypes#boolean) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [boolean](dataTypes#boolean) "
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "rectA"
                        },
                        {
                          "name": "rectB"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>返回是否和另一个长方形相交.</p>\n<p>此方法近判断是否相交, 不改变任何矩形:</p>\n<pre><code class=\"lang-js\">let rectA = new android.graphics.Rect(0, 0, 600, 600);\nlet rectB = new android.graphics.Rect(200, 0, 800, 800);\n\nconsole.log(android.graphics.Rect.intersects(rectA, rectB)); // true\n\n/* rectA 和 refB 均保持原来的值. */\nconsole.log(rectA); // Rect(0, 0 - 600, 600)\nconsole.log(rectB); // Rect(200, 0 - 800, 800)\n</code></pre>\n<p>需额外留意 <a href=\"#m-intersects\">intersects</a> 与 <a href=\"#m-intersect\">intersect</a> 的区别:</p>\n<ul>\n<li><p><code>[m#] intersect</code> 为实例方法, <code>rectA.intersect(rectB)</code> 需传入一个参数, 当相交时 <code>rectA</code> 会被改变, 返回结果为 &quot;是否相交&quot;.</p>\n</li>\n<li><p><code>[m] intersects</code> 为静态方法, <code>Rect.intersects(rectA, rectB)</code> 需传入两个参数, 且不改变任何矩形, 仅返回 &quot;是否相交&quot; 结果.</p>\n</li>\n</ul>\n"
                }
              ],
              "type": "module",
              "displayName": "[m] intersects"
            }
          ],
          "type": "module",
          "displayName": "AndroidRect"
        },
        {
          "textRaw": "AndroidBundle",
          "name": "androidbundle",
          "desc": "<p>android.os.Bundle 别名.<br>表示一个会被打包成捆的容器, 容器内可存储 <code>键值对 (Key-Value Pair)</code> 形式的数据.</p>\n<pre><code class=\"lang-js\">let bundleA = new android.os.Bundle();\nbundleA.putInt(&quot;num_key&quot;, 23);\nconsole.log(bundleA.getInt(&quot;num_key&quot;) === 23); // true\n\nlet bundleB = new android.os.Bundle();\nlet arrList = new java.util.ArrayList(2);\narrList.add(&quot;A&quot;);\narrList.add(&quot;B&quot;);\nbundleB.putStringArrayList(&quot;arr_list_key&quot;, arrList);\nconsole.log(bundleB.getStringArrayList(&quot;arr_list_key&quot;).get(0) === &quot;A&quot;); // true\nconsole.log(bundleB.getStringArrayList(&quot;arr_list_key&quot;).get(1) === &quot;B&quot;); // true\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"https://developer.android.com/reference/android/os/Bundle\">Android Docs</a></p>\n</blockquote>\n",
          "type": "module",
          "displayName": "AndroidBundle"
        },
        {
          "textRaw": "DetectCompass",
          "name": "detectcompass",
          "desc": "<p>用于传递给 <a href=\"uiObjectType#m-compass\">控件罗盘</a> 的参数类型, 又称 <code>罗盘参数</code>.</p>\n<p>罗盘参数是 <a href=\"dataTypes#string\">字符串</a> 类型, 支持单独或组合使用.</p>\n<p>下面列举了部分罗盘参数示例:</p>\n<ul>\n<li><code>p</code> - 父控件</li>\n<li><code>p2</code> - 二级父控件</li>\n<li><code>c0</code> - 索引 0 (首个) 子控件</li>\n<li><code>c2</code> - 索引 2 子控件</li>\n<li><code>c-1</code> - 末尾子控件</li>\n<li><code>s5</code> - 索引 5 兄弟控件</li>\n<li><code>s-2</code> - 倒数第 2 兄弟控件</li>\n<li><code>s&lt;1</code> - 相邻左侧兄弟节点</li>\n<li><code>s&gt;1</code> - 相邻右侧兄弟节点</li>\n<li><code>k2</code> - 向上寻找可点击控件 (最多 2 级)</li>\n<li><code>p4c0&gt;1&gt;1&gt;0s0</code> - 组合使用</li>\n</ul>\n<p><a href=\"uiObjectType#m-compass\">控件罗盘 (UiObject.compass)</a> 是 <a href=\"uiObjectType#m-detect\">控件探测 (UiObject.detect)</a> 的衍生方法, 因此类型命名采用了 <code>DetectCompass</code>.</p>\n",
          "type": "module",
          "displayName": "DetectCompass"
        },
        {
          "textRaw": "DetectResult",
          "name": "detectresult",
          "desc": "<p><a href=\"uiObjectType#m-detect\">控件探测 (UiObject.detect)</a> 的结果参数类型, 又称 <code>探测结果</code>, 此过程也称为 <code>结果筛选</code>.</p>\n<ul>\n<li><code># / w / widget</code> - <a href=\"uiObjectType\">控件</a></li>\n<li><code>$ / txt / content</code> - <a href=\"uiObjectType#m-content\">文本内容</a></li>\n<li><code>. / pt / point</code> - <a href=\"uiObjectType#m-point\">点</a></li>\n<li><code>UiObjectInvokable</code> - <a href=\"#uiobjectinvokable\">控件可调用类型</a></li>\n</ul>\n<pre><code class=\"lang-js\">/* 控件. */\ndetect(w, &#39;#&#39;);\ndetect(w, &#39;w&#39;); /* 同上. */\ndetect(w, &#39;widget&#39;); /* 同上. */\n\n/* 文本内容. */\ndetect(w, &#39;$&#39;);\ndetect(w, &#39;txt&#39;); /* 同上. */\ndetect(w, &#39;content&#39;); /* 同上. */\n\n/* 点. */\ndetect(w, &#39;.&#39;);\ndetect(w, &#39;pt&#39;); /* 同上. */\ndetect(w, &#39;point&#39;); /* 同上. */\n\n/* UiObjectInvokable (控件可调用类型). */\ndetect(w, &#39;click&#39;); /* i.e. w.click() */\ndetect(w, [ &#39;setText&#39;, &#39;hello&#39; ]); /* i.e. w.setText(&#39;hello&#39;) */\n</code></pre>\n<p>不同于 <a href=\"#pickupresult\">PickupResult (拾取结果)</a>, <code>探测结果</code> 的种类相对较少.</p>\n",
          "type": "module",
          "displayName": "DetectResult"
        },
        {
          "textRaw": "DetectCallback",
          "name": "detectcallback",
          "desc": "<p>探测回调.</p>\n<p>探测回调用于处理 <a href=\"uiObjectType#m-detect\">控件探测 (UiObject.detect)</a> 的结果.</p>\n<p><code>回调结果</code> 将影响 <code>探测结果</code>, 当 <code>回调结果</code> 返回 <code>undefined</code> 时, 将直接返回 <code>探测结果</code>, 否则返回 <code>回调结果</code>:</p>\n<pre><code class=\"lang-ts\">function detect&lt;T extends UiObject, R&gt;(w: T, callback: (w: T) =&gt; R): T | R {\n    let callbackResult: R = callback(w);\n    return callbackResult == undefined ? w : callbackResult;\n}\n</code></pre>\n<p>示例:</p>\n<pre><code class=\"lang-js\">let w = pickup(/.+/);\n\n/* 返回 w.content() 的结果. */\ndetect(w, (w) =&gt; w.content());\n\n/* 返回 w 的结果. */\ndetect(w, (w) =&gt; {\n    console.log(w.content());\n});\n</code></pre>\n",
          "type": "module",
          "displayName": "DetectCallback"
        },
        {
          "textRaw": "PickupSelector",
          "name": "pickupselector",
          "desc": "<p><a href=\"uiSelectorType#m-pickup\">拾取选择器</a> 的 <code>选择器参数</code>.</p>\n<p><code>选择器参数</code> 的类型分为 <a href=\"#单一型选择器\">单一型选择器</a> 和 <a href=\"#混合型选择器\">混合型选择器</a>.</p>\n",
          "modules": [
            {
              "textRaw": "单一型选择器",
              "name": "单一型选择器",
              "desc": "<p>单一型选择器包含 [ <a href=\"#经典选择器\">经典选择器</a> / <a href=\"#内容选择器\">内容选择器</a> / <a href=\"#对象选择器\">对象选择器</a> ].</p>\n",
              "modules": [
                {
                  "textRaw": "经典选择器",
                  "name": "经典选择器",
                  "desc": "<p><code>text(&#39;abc&#39;)</code> 或串联形式 <code>text(&#39;abc&#39;).clickable().centerX(0.5)</code>.</p>\n",
                  "type": "module",
                  "displayName": "经典选择器"
                },
                {
                  "textRaw": "内容选择器",
                  "name": "内容选择器",
                  "desc": "<p>字符串 <code>&#39;abc&#39;</code> 或正则表达式 <code>/abc/</code>.<br>相当于 <code>content(&#39;abc&#39;)</code> 及 <code>contentMatch(/abc/)</code>.</p>\n",
                  "type": "module",
                  "displayName": "内容选择器"
                },
                {
                  "textRaw": "对象选择器",
                  "name": "对象选择器",
                  "desc": "<p>将选择器名称作为 <code>键 (key)</code>, 选择器参数作为 <code>值 (value)</code>.<br>若参数多于 1 个, 使用数组包含所有参数; 若无参数, 使用 <code>[]</code> (空数组) 或 <code>null</code>, 或默认值 (如 <code>true</code>).<br>虽然一个参数也可使用数组, 但通常无必要.</p>\n<pre><code class=\"lang-js\">/* 经典选择器. */\nlet selClassic = text(&#39;abc&#39;).clickable().centerX(0.5).boundsInside(0.2, 0.05, -1, -1).action(&#39;CLICK&#39;, &#39;SET_TEXT&#39;, &#39;LONG_CLICK&#39;);\n\n/* 对象选择器. */\nlet selObject = {\n    text: &#39;abc&#39;,\n    clickable: [], /* 或 clickable: true . */\n    centerX: 0.5,\n    boundsInside: [ 0.2, 0.05, -1, -1 ],\n    action: [ &#39;CLICK&#39;, &#39;SET_TEXT&#39;, &#39;LONG_CLICK&#39; ],\n};\n</code></pre>\n",
                  "type": "module",
                  "displayName": "对象选择器"
                }
              ],
              "type": "module",
              "displayName": "单一型选择器"
            },
            {
              "textRaw": "混合型选择器",
              "name": "混合型选择器",
              "desc": "<p>混合型选择器由多个单一型选择器组成.</p>\n<p>用数组表示一个混合型选择器, 其中的元素为单一型选择器:</p>\n<pre><code class=\"lang-js\">pickup([ /he.+/, clickable(true).boundsInside(0.2, 0.05, -1, -1) ]);\n</code></pre>\n<p>上述示例的选择器参数使用了混合型选择器, 它包含两个单一型选择器, 分别为 <a href=\"#内容选择器\">内容选择器</a> 和 <a href=\"#经典选择器\">经典选择器</a>.</p>\n<p>上述示例可以转换为单一型选择器:</p>\n<pre><code class=\"lang-js\">/* 对象选择器. */\npickup({\n    contentMatch: /he.+/,\n    clickable: true,\n    boundsInside: [ 0.2, 0.05, -1, -1 ],\n});\n\n/* 经典选择器. */\npickup(contentMatch(/he.+/).clickable(true).boundsInside(0.2, 0.05, -1, -1));\n</code></pre>\n",
              "type": "module",
              "displayName": "混合型选择器"
            }
          ],
          "type": "module",
          "displayName": "PickupSelector"
        },
        {
          "textRaw": "PickupResult",
          "name": "pickupresult",
          "desc": "<p><a href=\"uiSelectorType#m-pickup\">拾取选择器 (UiSelector#pickup)</a> 的结果参数类型, 又称 <code>拾取结果</code>, 此过程也称为 <code>结果筛选</code>.</p>\n<ul>\n<li><code># / w / widget</code> - <a href=\"uiObjectType\">控件 (UiObject)</a></li>\n<li><code>{} / #{} / {#} / w{} / {w} / wc / collection / list</code> -&gt; <a href=\"uiObjectCollectionType\">控件集合 (UiObjectCollection)</a></li>\n<li><code>[] / #[] / [#] / w[] / [w] / ws / widgets</code> -&gt; <a href=\"uiObjectType\">控件 (UiObject)</a> 数组</li>\n<li><code>$ / txt / content</code> - <a href=\"uiObjectType#m-content\">文本内容 (UiObject#content)</a></li>\n<li><code>$[] / [$] / txt[] / [txt] / content[] / [content] / contents</code> -&gt; <a href=\"uiObjectType#m-content\">文本内容 (UiObject#content)</a> 数组</li>\n<li><code>. / pt / point</code> - <a href=\"uiObjectType#m-point\">点 (UiObject#point)</a></li>\n<li><code>.[] / [.] / point[] / [point] / pt[] / [pt] / points / pts</code> -&gt; <a href=\"uiObjectType#m-point\">点 (UiObject#point)</a> 数组</li>\n<li><code>@ / selector / sel</code> -&gt; <a href=\"uiSelectorType\">选择器 (UiSelector)</a></li>\n<li><code>? / exists</code> -&gt; <a href=\"uiSelectorType#m-exists\">存在判断 (UiSelector#exists)</a></li>\n<li><code>UiObjectInvokable</code> - <a href=\"#uiobjectinvokable\">控件可调用类型</a></li>\n</ul>\n<pre><code class=\"lang-js\">/* 控件. */\npickup(sel, &#39;#&#39;);\npickup(sel, &#39;w&#39;); /* 同上. */\npickup(sel, &#39;widget&#39;); /* 同上. */\n\n/* 文本内容. */\npickup(sel, &#39;$&#39;);\npickup(sel, &#39;txt&#39;); /* 同上. */\npickup(sel, &#39;content&#39;); /* 同上. */\n\n/* 文本内容数组. */\npickup(sel, &#39;$[]&#39;);\npickup(sel, &#39;txt[]&#39;); /* 同上. */\npickup(sel, &#39;[content]&#39;); /* 同上. */\npickup(sel, &#39;contents&#39;); /* 同上. */\n\n/* 点. */\npickup(sel, &#39;.&#39;);\npickup(sel, &#39;pt&#39;); /* 同上. */\npickup(sel, &#39;point&#39;); /* 同上. */\n\n/* 点数组. */\npickup(sel, &#39;.[]&#39;);\npickup(sel, &#39;[.]&#39;); /* 同上. */\npickup(sel, &#39;[point]&#39;); /* 同上. */\npickup(sel, &#39;points&#39;); /* 同上. */\n\n/* UiObjectInvokable (控件可调用类型). */\npickup(sel, &#39;click&#39;); /* i.e. sel.findOnce().click() */\npickup(sel, [ &#39;setText&#39;, &#39;hello&#39; ]); /* i.e. sel.findOnce().setText(&#39;hello&#39;) */\n</code></pre>\n<p>与 <a href=\"#detectresult\">DetectResult (探测结果)</a> 相比, <code>拾取结果</code> 的种类更加丰富.</p>\n",
          "type": "module",
          "displayName": "PickupResult"
        },
        {
          "textRaw": "UiObjectInvokable",
          "name": "uiobjectinvokable",
          "desc": "<p>控件可调用类型, 用于使用参数形式实现方法调用, 又称 <code>参化调用</code>.</p>\n<p>支持所有 <a href=\"uiObjectType\">UiObject</a> 的实例方法, 如果方法需要传递参数, 需要将参数连同方法名称放入数组后再传递.</p>\n<pre><code class=\"lang-js\">/* 无参方法. */\ndetect(w, &#39;click&#39;); /* i.e. w.click() */\ndetect(w, &#39;imeEnter&#39;); /* i.e. w.imeEnter() */\n\n/* 含参方法. */\ndetect(w, [ &#39;child&#39;, 0 ]); /* i.e. w.child(0) */\ndetect(w, [ &#39;setText&#39;, &#39;hello&#39; ]); /* i.e. w.setText(&#39;hello&#39;) */\ndetect(w, [ &#39;setSelection&#39;, 2, 3 ]); /* i.e. w.setSelection(2, 3) */\n</code></pre>\n",
          "type": "module",
          "displayName": "UiObjectInvokable"
        }
      ],
      "type": "module",
      "displayName": "自定义类型"
    }
  ]
}